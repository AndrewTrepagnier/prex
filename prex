#!/usr/bin/env bash
set -euo pipefail

# Color helpers
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

function echo_info() { echo -e "ðŸ¤– ${YELLOW}âžœ $*${NC}"; }
function echo_success() { echo -e "ðŸ¤– ${GREEN}âœ” $*${NC}"; }
function echo_error() { echo -e "ðŸ¤– ${RED}âœ˜ $*${NC}"; }




function prex_face() {
  cat << 'EOF'
à¼¼ ã¤ â—•_â—• à¼½ã¤
ðŸ¤– prex â€” your helpful git bot
EOF
}




function prex_success() {
  echo
  echo -e "${GREEN}à¼¼ ã¤ â—•_â—• à¼½ã¤${NC}"
  echo -e "${GREEN}ðŸ¤– Done! Resolved rebase conflict and pushed to GitHub.${NC}"
  echo
}




function current_branch() {
  local branch
  branch=$(git symbolic-ref --quiet --short HEAD 2>/dev/null || true)
  if [[ -z "$branch" ]]; then
    if [[ -f .git/rebase-apply/head-name ]]; then
      branch=$(cat .git/rebase-apply/head-name | sed 's|refs/heads/||')
    elif [[ -f .git/rebase-merge/head-name ]]; then
      branch=$(cat .git/rebase-merge/head-name | sed 's|refs/heads/||')
    else
      echo_error "Cannot determine current branch."
      exit 1
    fi
  fi
  echo "$branch"
}




function rebase_in_progress() {
  [[ -d .git/rebase-apply ]] || [[ -d .git/rebase-merge ]]
}




function has_conflicts() {
  [[ -n "$(git diff --name-only --diff-filter=U 2>/dev/null)" ]]
}




function ensure_git_repo() {
  git rev-parse --is-inside-work-tree &>/dev/null || {
    echo_error "Not inside a git repository."
    exit 1
  }
}




function show_conflict_help() {
  echo -e "${YELLOW}"
  cat << 'EOF'
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  CONFLICT MARKERS GUIDE                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  <<<<<<< HEAD                                   â”‚
â”‚    (your local changes)                         â”‚
â”‚  =======                                        â”‚
â”‚    (remote changes from GitHub)                 â”‚
â”‚  >>>>>>> commit_hash                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1. Keep the code you want                      â”‚
â”‚  2. Delete ALL marker lines (<<<, ===, >>>)    â”‚
â”‚  3. Save and quit (:wq)                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
EOF
  echo -e "${NC}"
}





function resolve_conflicts() {
  while has_conflicts; do
    local conflicted_file
    conflicted_file=$(git diff --name-only --diff-filter=U | head -n 1)
    
    echo_info "Conflict in: $conflicted_file"
    show_conflict_help
    
    echo_info "Opening in vim... (save and quit when done)"
    vim "$conflicted_file"
    
    # Stage the resolved file
    git add "$conflicted_file"
    echo_success "Staged: $conflicted_file"
  done
}







function repair() {
  local branch
  branch=$(current_branch)
  
  # If already in a rebase, jump straight to conflict resolution
  if rebase_in_progress; then
    echo_info "Rebase already in progress, resuming..."
    
    if has_conflicts; then
      resolve_conflicts
    fi
    
    # Continue the rebase
    while rebase_in_progress; do
      if ! git rebase --continue 2>/dev/null; then
        if has_conflicts; then
          resolve_conflicts
        else
          echo_error "Rebase failed for unknown reason."
          exit 1
        fi
      fi
    done
    
    echo_info "Pushing to origin/$branch..."
    git push origin "$branch"
    prex_success
    return
  fi
  
  # Fresh repair: fetch and rebase
  echo_info "Fetching origin..."
  git fetch origin
  
  # Check if we're behind
  local local_commit remote_commit
  local_commit=$(git rev-parse HEAD)
  remote_commit=$(git rev-parse "origin/$branch" 2>/dev/null || echo "")
  
  if [[ -z "$remote_commit" ]]; then
    echo_info "No remote branch origin/$branch found. Nothing to repair."
    exit 0
  fi
  
  if git merge-base --is-ancestor "origin/$branch" HEAD 2>/dev/null; then
    echo_success "Already up to date with origin/$branch"
    echo_info "Pushing to origin/$branch..."
    git push origin "$branch"
    echo_success "All synced!"
    exit 0
  fi
  
  echo_info "Rebasing $branch onto origin/$branch..."
  
  # Start rebase, handle conflicts if they occur
  if ! git rebase "origin/$branch" 2>/dev/null; then
    if has_conflicts; then
      echo_info "Conflicts detected! Let's fix them..."
      resolve_conflicts
      
      # Continue rebase after resolving
      while rebase_in_progress; do
        if ! git rebase --continue 2>/dev/null; then
          if has_conflicts; then
            resolve_conflicts
          else
            echo_error "Rebase failed."
            exit 1
          fi
        fi
      done
    else
      echo_error "Rebase failed for unknown reason."
      exit 1
    fi
  fi
  
  echo_info "Pushing to origin/$branch..."
  git push origin "$branch"
  prex_success
}








function reconnect() {
  local current_url
  current_url=$(git remote get-url origin 2>/dev/null || echo "")
  
  if [[ -n "$current_url" ]]; then
    # Origin exists â€” show it, disconnect, reconnect
    echo_info "Current remote origin: $current_url"
    echo
    echo_info "Disconnecting from origin..."
    git remote remove origin
    echo_success "Disconnected from origin."
    echo
    echo_info "Reconnecting to origin..."
    git remote add origin "$current_url"
    echo_success "Reconnected to: $current_url"
    echo
    echo_info "Verifying connection..."
    if git ls-remote origin &>/dev/null; then
      echo_success "Connection verified! Remote is reachable."
    else
      echo_error "Could not reach remote. Check your URL or network."
    fi
  else
    # No origin â€” ask politely for URL
    prex_face
    echo
    echo -e "ðŸ¤– ${YELLOW}Hmm, I don't see a remote origin set up.${NC}"
    echo -e "ðŸ¤– ${YELLOW}What URL would you like me to connect to?${NC}"
    echo
    echo -n "ðŸ¤– âžœ Enter remote URL: "
    read -r new_url
    
    if [[ -z "$new_url" ]]; then
      echo_error "No URL provided. Aborting."
      exit 1
    fi
    
    echo
    echo_info "Connecting to origin..."
    git remote add origin "$new_url"
    echo_success "Connected to: $new_url"
    echo
    echo_info "Verifying connection..."
    if git ls-remote origin &>/dev/null; then
      echo_success "Connection verified! Remote is reachable."
    else
      echo_error "Could not reach remote. Check your URL or credentials."
    fi
  fi
}

function usage() {
  prex_face
  echo
  echo "Usage:"
  echo "  prex repair      Fix conflicts and sync with GitHub"
  echo "  prex reconnect   Disconnect and reconnect remote origin"
  echo "  prex abort       Abort a repair in progress"
  echo
}








# === Main ===
cmd="${1:-}"

if [[ -z "$cmd" ]]; then
  prex_face
  echo "ðŸ¤– prex is ready. Run 'prex repair' to fix conflicts."
  exit 0
fi

ensure_git_repo

case "$cmd" in
  repair)
    repair
    ;;
  reconnect)
    reconnect
    ;;
  abort)
    if rebase_in_progress; then
      echo_info "Aborting rebase..."
      git rebase --abort
      echo_success "Aborted. Back to where you started."
    else
      echo_info "Nothing to abort."
    fi
    ;;
  *)
    usage
    ;;
esac
